# Chp 1
CPU时钟周期：CPU最小的时间单位
$$CPU主频=\frac{1}{CPU时钟周期}$$
CPI：执行一条指令所需要的时钟周期数
CPU执行时间：运行一个程序所花费的时间
$$CPU执行时间=指令条数 \times CPI \times \frac{1}{CPU主频}$$
MIPS：每秒所执行的指令数（以百万计）
MFLOPS：每秒所执行的浮点计算数（以百万计）

# Chp 2
负数：原码取反变反码，反码加一变补码，

# Chp 3
PC：存放下一个要执行指令的==虚拟逻辑地址==
程序要访问内存时，由于虚拟内存机制，所需要访问的内存地址通常需要进行转换才能得到具体的物理主存地址
- 在基本分页的情况下，得知虚拟地址以及页号、偏移量的位数（例如`vAddr=0010`，`dg=(2,2)`位于第0页的2号偏移位），就能通过查页表的方式将页号转换为页框号（例如第0页在主存中对应3号页框，最终地址就是`addr=...011 10`）。对于经常访问的页，还会将其自动整理进Cache中的【快表】中方便快速访问
页表：转换虚拟地址和物理地址的数据表，其本身存放在主存中（对于一些经常访问的页面，还会将其存放进快表中）
页框：主存中对应页表页号的真实地址号，大小与页一致
多级页表：当程序页表的大小超过了页框大小时就会进行页表的多级嵌套
- 例如一个程序有500个页，
- 多级页表的本质不是为了节省空间，而是用于充分利用随机访问机制将内存页拆开
- 顶级页表大小$\le$页框大小，其他页表大小$=$页框大小
请求分页：虚拟存储器，利用硬盘在逻辑上扩大内存，其最大容量大小$=\min(S_{CPU+RAM},S_{逻辑地址范围})$

# Chp 4
寻址方式：
## 隐含寻址
1. 在进行2个操作数运算时，其中一个操作数由形式地址A给出，此时访问主存一次，另外一个操作数隐含在ACC寄存器中。
2. 在进行1个操作数运算时，唯一的操作数隐含在ACC寄存器中，此时不访问主存
## 立即寻址
1. 指令直接包含操作数
```
// 表法及指针
A == x
```
## 直接寻址
1. 指令包含的字段A就是有效地址
2. 有效地址直接指向操作数
```
// 表法
A == EA -> x;
// 指针
*(EA) == x;
```

## 间接寻址
```
// 表法
A == B -> EA -> x;
// 指针
A == B;
*(B) == EA;
*(EA) == x;
```

## 寄存器寻址
1. 与直接寻址类似，字段A指的是寄存器地址，寄存器内存放的就是操作数

## 寄存器间接寻址
1. 与间接寻址类似，字段A指的是寄存器地址，寄存器内存放的是有效地址，有效地址内存放的是操作数

## 相对寻址
1. 相对寻址需要用到PC的值，使其与字段A相加后得到有效地址
```
// 表法
A + PC == EA -> x;
// 指针
A + PC == EA;
*(EA) == x;
```

## 基址寻址
1. 和相对寻址类似，基址需要用到BR的值（一般是程序开头），使其与字段A相加后得到有效地址
```
// 表法
A + BR == EA -> x;
// 指针
A + BR == EA;
*(EA) == x;
```

## 变址寻址
1. 和基址寻址类似，变址需要用到BR的值（一般是程序开头），使其与字段A相加后得到有效地址
```
// 表法
A + BR == EA -> x;
// 指针
A + BR == EA;
*(EA) == x;
```